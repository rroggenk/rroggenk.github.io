{
  "hash": "5cae28095f4ed01c452284a44c0ecef0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lab 6: Code Efficiency\"\ndescription: \"Performing Many Different Versions of an Analysis\"\nauthor: \"Rachel Roggenkemper\"\ndate: \"05-12-2025\"\ncategories: [Quarto, R]\nimage: preview-image.png\nformat: html\nembed-resources: true\neditor: source\nexecute: \n  echo: true\n  warning: false\n---\n\n\n\n\n*Note: I did use AI to help me think of scenarios where I needed to add warnings for my functions. I was able to account for the scenarios that are provided in the tests for the functions, but to make the functions more applicable, I wanted it to be able to handle additional scenarios (like if the user inputs a column that doesn't exist in the dataframe).*\n\nThis assignment will challenge your function writing abilities. I'm not going to lie, these functions are difficult but well within your reach. I do, however, want to recognize that not everyone is interested in being a \"virtuoso\" with their function writing. So, there are two options for this week's lab:\n\n-   **Option 1:** Complete this lab assignment in search of virtuoso status with your function writing\n-   **Option 2:** Complete one of the difficult functions (Exercise 1 or Exercise 2 and complete the \"Alternative Lab 6\".\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\n# Setting the Stage\n\nMy number one use case for writing functions and iteration / looping is to perform some exploration or modeling repeatedly for different \"tweaked\" versions. For example, our broad goal might be to fit a linear regression model to our data. However, there are often multiple choices that we have to make in practice:\n\n-   Keep missing values or fill them in (imputation)?\n-   Filter out outliers in one or more variables?\n\nWe can map these choices to **arguments** in a custom model-fitting function:\n\n-   `impute`: TRUE or FALSE\n-   `remove_outliers`: TRUE or FALSE\n\nA function that implements the analysis and allows for variation in these choices:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model <- function(df, impute, remove_outliers, mod) {\n    if (impute) {\n        df <- some_imputation_function(df)\n    }\n    \n    if (remove_outliers) {\n        df <- function_for_removing_outliers(df)\n    }\n    \n    lm(mod, data = df)\n}\n```\n:::\n\n\n\n\n# Helper Functions\n\n**Exercise 1:** Write a function that removes outliers in a dataset. The user should be able to supply the dataset, the variables to remove outliers from, and a threshold on the number of SDs away from the mean used to define outliers. *Hint 1: You will need to calculate a z-score to filter the values!* *Hint 2: You might want to consider specifying a default value (e.g., 3) for `sd_thresh`.*\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Removes rows where specified numeric columns have outliers.\n#'\n#' @param df A data frame.\n#' @param ... Unquoted names of columns to check for outliers.\n#' @param sd_thresh Numeric. Number of standard deviations from the mean to define an outlier. Default is 3.\n#' @return A filtered data frame with outliers removed from selected numeric columns.\n\n\nremove_outliers <- function(df, ..., sd_thresh = 3) {\n  # Grab the columns the user passed in through ...\n  vars_to_check <- rlang::enquos(...)\n\n  # If no varaibles were given, return the og data with a warning\n  if (length(vars_to_check) == 0) {\n    warning(\"No variables specified for outlier removal. Returning original data.\")\n    return(df)\n  }\n\n  # Extract the user given col names \n  selected_col_names <- purrr::map_chr(vars_to_check, rlang::as_name)\n\n  # Keep only cols that actually exist in the data\n  existing_selected_cols <- selected_col_names[selected_col_names %in% colnames(df)]\n  non_existing_cols <- setdiff(selected_col_names, existing_selected_cols)\n\n  # Warn the user if they referenced any cols that don’t exist\n  if (length(non_existing_cols) > 0) {\n    warning(\"These columns don’t exist and will be ignored: \",\n            paste(non_existing_cols, collapse = \", \"))\n  }\n\n  # Of the valid cols, figure out which ones are numeric\n  if (length(existing_selected_cols) > 0) {\n    numeric_cols_to_process <- df %>%\n      select(all_of(existing_selected_cols)) %>%\n      select(where(is.numeric)) %>%\n      colnames()\n  } else {\n    numeric_cols_to_process <- character(0)\n  }\n\n  # Warn if any of the selected cols are not numeric\n  non_numeric_selected <- setdiff(existing_selected_cols, numeric_cols_to_process)\n  if (length(non_numeric_selected) > 0) {\n    warning(\"These columns aren’t numeric and will be ignored: \",\n            paste(non_numeric_selected, collapse = \", \"))\n  }\n\n  # If we have nothing numeric to check, return the og data\n  if (length(numeric_cols_to_process) == 0) {\n    if (length(existing_selected_cols) > 0) {\n      warning(\"None of the specified variables are numeric. Returning original data.\")\n    }\n    return(df)\n  }\n\n  # Filter the data to keep only rows where all specified numeric vars\n  # are either NA or within the sd_thresh cutoff (i.e., not outliers)\n  df_filtered <- df %>%\n    filter(\n      if_all(\n        all_of(numeric_cols_to_process),\n        ~ {\n          m <- mean(., na.rm = TRUE)\n          s <- sd(., na.rm = TRUE)\n\n          if (is.na(s) || s == 0) {\n            TRUE  # If sd=0, don’t remove anything\n          } else {\n            abs((. - m) / s) <= sd_thresh  # Keep if within threshold\n          }\n        } | is.na(.)  # Always keep NA values\n      )\n    )\n\n  return(df_filtered)\n}\n```\n:::\n\n\n\n\n## Testing Your Function!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles multiple input variables\nremove_outliers(diamonds, \n                price, \n                x, \n                y, \n                z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 52,689 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 52,679 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles an input that isn't numeric\nremove_outliers(diamonds, \n                price, \n                color)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 52,734 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 52,724 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles a non-default sd_thresh\nremove_outliers(diamonds, \n                price,\n                x, \n                y, \n                z, \n                sd_thresh = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 50,099 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 50,089 more rows\n```\n\n\n:::\n:::\n\n\n\n\n**Exercise 2:** Write a function that imputes missing values for numeric variables in a dataset. The user should be able to supply the dataset, the variables to impute values for, and a function to use when imputing. *Hint 1: You will need to use `across()` to apply your function, since the user can input multiple variables.* *Hint 2: The `replace_na()` function is helpful here!*\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Imputes missing values in specified numeric columns using a summary function.\n#'\n#' @param df A data frame.\n#' @param ... Unquoted column names to impute.\n#' @param impute_fun A function like `mean` or `median` used to compute replacement values. Default is `mean`.\n#' @return A data frame where NAs in the selected numeric columns are replaced.\n\n\nimpute_missing <- function(df, ..., impute_fun = mean) {\n  # Capture the unquoted col names\n  vars_to_impute <- rlang::enquos(...)\n\n  # If the user doesn’t pass any vars, just return the og data\n  if (length(vars_to_impute) == 0) {\n    warning(\"No variables specified for imputation. Returning original data.\")\n    return(df)\n  }\n\n  # Extract the user given col names \n  selected_col_names <- purrr::map_chr(vars_to_impute, rlang::as_name)\n\n  # Only keep columns that actually exist in the data\n  existing_selected_cols <- selected_col_names[selected_col_names %in% names(df)]\n  non_existing_cols <- setdiff(selected_col_names, existing_selected_cols)\n\n  # Warn if any user-specified cols weren’t found\n  if (length(non_existing_cols) > 0) {\n    warning(\"These columns don’t exist in the data and will be skipped: \",\n            paste(non_existing_cols, collapse = \", \"))\n  }\n\n  # From the valid cols, keep only the numeric ones\n  if (length(existing_selected_cols) > 0) {\n    numeric_cols_to_process <- df %>%\n      select(any_of(existing_selected_cols)) %>%\n      select(where(is.numeric)) %>%\n      colnames()\n  } else {\n    numeric_cols_to_process <- character(0)\n  }\n\n  # Warn if any of the selected cols aren’t numeric\n  non_numeric_selected <- setdiff(existing_selected_cols, numeric_cols_to_process)\n  if (length(non_numeric_selected) > 0) {\n    warning(\"These columns are not numeric and will be ignored: \",\n            paste(non_numeric_selected, collapse = \", \"))\n  }\n\n  # If there’s nothing numeric to process, just return the og data\n  if (length(numeric_cols_to_process) == 0) {\n    if (length(existing_selected_cols) > 0 && length(non_existing_cols) < length(selected_col_names)) {\n      warning(\"No numeric columns found among selected variables. Returning original data.\")\n    }\n    return(df)\n  }\n\n  # Go through each selected numeric col and fill in the missing vals\n  df_imputed <- df %>%\n    mutate(\n      across(\n        all_of(numeric_cols_to_process),\n        ~ {\n          current_col_name <- cur_column()\n          valid_values <- .[!is.na(.)]\n\n          # Start with NA in case we can’t compute a valid value\n          imputation_value <- NA\n\n          # If the whole column is NA, we can't impute anything, so leave it as is\n          if (length(valid_values) == 0) {\n            imputation_value <- NA\n          } else {\n            # Try applying the user-specified function to get a value\n            temp_imputation_value <- tryCatch(\n              impute_fun(valid_values),\n              error = function(e) {\n                warning(paste0(\"Problem applying impute_fun to '\", current_col_name, \n                               \"': \", e$message, \". Leaving NAs as-is.\"))\n                return(NA)\n              }\n            )\n\n            # Only keep the result if it’s one number / a single value\n            # Gemmy advised to add this step \n            if (length(temp_imputation_value) == 1 && is.atomic(temp_imputation_value)) {\n              imputation_value <- temp_imputation_value\n            } else {\n              warning(paste0(\"Imputation function for '\", current_col_name, \n                             \"' didn’t return a single value. Leaving NAs as-is.\"))\n              imputation_value <- NA\n            }\n          }\n\n          # Fill in missing values with the computed imputation value\n          tidyr::replace_na(., imputation_value)\n        }\n      )\n    )\n\n  return(df_imputed)\n}\n```\n:::\n\n\n\n\n## Testing Your Function!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles multiple input variables\nimpute_missing(nycflights13::flights, \n               arr_delay, \n               dep_delay) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles an input that isn't numeric\nimpute_missing(nycflights13::flights, \n               arr_delay, \n               carrier)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles a non-default impute_fun\nimpute_missing(nycflights13::flights, \n               arr_delay, \n               dep_delay, \n               impute_fun = median)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n# Primary Function\n\n**Exercise 3:** Write a `fit_model()` function that fits a specified linear regression model for a specified dataset. The function should:\n\n-   allow the user to specify if outliers should be removed (`TRUE` or `FALSE`)\n-   allow the user to specify if missing observations should be imputed (`TRUE` or `FALSE`)\n\nIf either option is `TRUE`, your function should call your `remove_outliers()` or `impute_missing()` functions to modify the data **before** the regression model is fit.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Fits a linear model with optional data preprocessing.\n#'\n#' @param df A data frame.\n#' @param mod_formula A model formula (or a string that can be converted to one).\n#' @param remove_outliers Logical. If TRUE, runs remove_outliers() on specified columns.\n#' @param impute_missing Logical. If TRUE, runs impute_missing() on specified columns.\n#' @param ... Unquoted names of columns to use for preprocessing (outlier removal and/or imputation).\n#' @return A fitted lm object.\n\n\nfit_model <- function(df, mod_formula, remove_outliers = FALSE, impute_missing = FALSE, ...) {\n  # Grab the vars the user passed to ... \n  vars_for_processing <- rlang::enquos(...)\n\n  # Work on a copy of the dataset so we don’t overwrite the og\n  processed_df <- df\n\n  # If user wants to remove outliers, run that step first\n  if (remove_outliers) {\n    processed_df <- remove_outliers(processed_df, !!!vars_for_processing)\n    message(paste(\"After outlier removal, data has\", nrow(processed_df), \"rows.\"))\n  }\n\n  # If user wants to fill in missing values, run that next\n  if (impute_missing) {\n    processed_df <- impute_missing(processed_df, !!!vars_for_processing)\n    message(\"Missing value imputation applied (if needed).\")\n  }\n\n  # Make sure the model formula is actually a formula object\n  if (!inherits(mod_formula, \"formula\")) {\n    current_env <- rlang::caller_env()\n    mod_formula_str <- mod_formula\n    mod_formula <- tryCatch(\n      stats::as.formula(mod_formula, env = current_env),\n      error = function(e) {\n        stop(paste0(\"mod_formula '\", mod_formula_str, \"' couldn’t be converted to a formula: \", e$message))\n      }\n    )\n  }\n\n  # Try fitting the model and return it\n  model <- tryCatch({\n    stats::lm(mod_formula, data = processed_df)\n  }, error = function(e) {\n    stop(paste0(\"Model fitting failed: \", e$message,\n                \"\\nAfter preprocessing, data had \",\n                nrow(processed_df), \" rows and \", ncol(processed_df), \" columns.\"))\n  })\n\n  return(model)\n}\n```\n:::\n\n\n\n\n## Testing Your Function!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model(\n  diamonds,\n  mod_formula = price ~ carat + cut,\n  remove_outliers = TRUE,\n  impute_missing = TRUE,\n  price, \n  carat\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nstats::lm(formula = mod_formula, data = processed_df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2460.16      7526.96      1059.65      -410.54       295.80        82.62  \n```\n\n\n:::\n:::\n\n\n\n\n# Iteration\n\nIn the `diamonds` dataset, we want to understand the relationship between `price` and size (`carat`). We want to explore variation along two choices:\n\n1.  The variables included in the model. We'll explore 3 sets of variables:\n\n    -   No further variables (just `price` and `carat`)\n    -   Adjusting for `cut`\n    -   Adjusting for `cut` and `clarity`\n    -   Adjusting for `cut`, `clarity`, and `color`\n\n2.  Whether or not to impute missing values\n\n3.  Whether or not to remove outliers in the `carat` variable (we'll define outliers as cases whose `carat` is over 3 SDs away from the mean).\n\n## Parameters\n\nFirst, we need to define the set of parameters we want to iterate the `fit_model()` function over. The `tidyr` package has a useful function called `crossing()` that is useful for generating argument combinations. For each argument, we specify all possible values for that argument and `crossing()` generates all combinations. *Note that you can create a list of formula objects in R with `c(y ~ x1, y ~ x1 + x2)`.*\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_arg_combos <- crossing(\n    impute = c(TRUE, FALSE),\n    remove_outliers = c(TRUE, FALSE), \n    mod = c(y ~ x1, \n            y ~ x1 + x2)\n)\ndf_arg_combos\n```\n:::\n\n\n\n\n**Exercise 4:** Use `crossing()` to create the data frame of argument combinations for our analyses.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Set up the different model formulas \n# Each one adds more predictors to see how the model changes\nmodel_formulas <- list(\n  price ~ carat,\n  price ~ carat + cut,\n  price ~ carat + cut + clarity,\n  price ~ carat + cut + clarity + color\n)\n\n# Step 2: Decide whether or not to impute missing values\n# Test both options: with and without imputation\nimputation_options <- c(TRUE, FALSE)\n\n# Step 3: Decide whether or not to remove outliers\n# Test both options: with and without removing outliers\noutlier_removal_options <- c(TRUE, FALSE)\n\n# Step 4: Create all possible combinations of the above choices\n# crossing() makes a data frame with every combo of formula, impute, and outlier setting\n# These column names match the argument names used in the fit_model() function\ndf_arg_combos <- tidyr::crossing(\n  mod_formula = model_formulas,\n  impute_missing = imputation_options,\n  remove_outliers = outlier_removal_options\n)\n\n# Step 5: Take a look at the combinations created\n# There should be 4 formulas × 2 impute options × 2 outlier options = 16 total\nprint(df_arg_combos)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 3\n   mod_formula impute_missing remove_outliers\n   <list>      <lgl>          <lgl>          \n 1 <formula>   FALSE          FALSE          \n 2 <formula>   FALSE          TRUE           \n 3 <formula>   TRUE           FALSE          \n 4 <formula>   TRUE           TRUE           \n 5 <formula>   FALSE          FALSE          \n 6 <formula>   FALSE          TRUE           \n 7 <formula>   TRUE           FALSE          \n 8 <formula>   TRUE           TRUE           \n 9 <formula>   FALSE          FALSE          \n10 <formula>   FALSE          TRUE           \n11 <formula>   TRUE           FALSE          \n12 <formula>   TRUE           TRUE           \n13 <formula>   FALSE          FALSE          \n14 <formula>   FALSE          TRUE           \n15 <formula>   TRUE           FALSE          \n16 <formula>   TRUE           TRUE           \n```\n\n\n:::\n:::\n\n\n\n\n## Iterating Over the Parameters\n\nWe've arrived at the final step!\n\n**Exercise 5:** Use `pmap()` from `purrr` to apply the `fit_model()` function to every combination of arguments from \\`diamonds.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Apply fit_model() to each row of df_arg_combos\n# This will run all the combinations of formula, outlier removal, and imputation\n\nmessage(\"Starting model fitting for \", nrow(df_arg_combos), \" combinations...\")\n\ndf_results <- df_arg_combos %>%\n  mutate(\n    model_object = purrr::pmap(\n      # .l = list of arguments to vary; must match fit_model()’s argument names\n      .l = list(\n        mod_formula = mod_formula,\n        impute_missing = impute_missing,\n        remove_outliers = remove_outliers\n      ),\n      # .f = function to call on each row\n      .f = fit_model,\n      # These arguments are the same across all rows\n      df = diamonds,\n      carat  # Passed to ... inside fit_model; used for preprocessing\n    )\n  )\n\nmessage(\"Model fitting complete. Results are saved in 'df_results'.\")\n\n# Checking results:— each row should include the fitted model\nprint(df_results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 4\n   mod_formula impute_missing remove_outliers model_object\n   <list>      <lgl>          <lgl>           <list>      \n 1 <formula>   FALSE          FALSE           <lm>        \n 2 <formula>   FALSE          TRUE            <lm>        \n 3 <formula>   TRUE           FALSE           <lm>        \n 4 <formula>   TRUE           TRUE            <lm>        \n 5 <formula>   FALSE          FALSE           <lm>        \n 6 <formula>   FALSE          TRUE            <lm>        \n 7 <formula>   TRUE           FALSE           <lm>        \n 8 <formula>   TRUE           TRUE            <lm>        \n 9 <formula>   FALSE          FALSE           <lm>        \n10 <formula>   FALSE          TRUE            <lm>        \n11 <formula>   TRUE           FALSE           <lm>        \n12 <formula>   TRUE           TRUE            <lm>        \n13 <formula>   FALSE          FALSE           <lm>        \n14 <formula>   FALSE          TRUE            <lm>        \n15 <formula>   TRUE           FALSE           <lm>        \n16 <formula>   TRUE           TRUE            <lm>        \n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}